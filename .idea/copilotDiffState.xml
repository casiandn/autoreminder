<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="updatedContent" value="# AutoReminder (core)&#10;&#10;A lightweight Java scheduling &amp; domain prototype for managing scheduled events — birthdays, anniversaries, reminders, meetings.&#10;&#10;This project is designed with a Hexagonal (Ports &amp; Adapters) architecture: the core domain is framework- and infra-agnostic so adapters (in-memory, logging, Kafka, JPA, etc.) can be added later.&#10;&#10;Summary&#10;- Domain models scheduled events with recurrence rules: `NONE`, `DAILY`, `WEEKLY`, `MONTHLY`, `YEARLY`.&#10;- `ManageEventService` exposes CRUD + scheduling operations:&#10;  - `createEvent`, `getEvent`, `listEvents`, `updateEvent`, `deleteEvent`&#10;  - `nextOccurrence(UUID, ZonedDateTime)`&#10;  - `findDueEvents(ZonedDateTime)`&#10;  - `triggerDueEvents(ZonedDateTime)`&#10;- Infrastructure adapters live under `infrastructure/` and implement ports from `domain.ports.out`.&#10;- Lombok is used in the domain model to reduce boilerplate (`Event`).&#10;&#10;What’s in this repository&#10;&#10;Source layout (high level)&#10;```&#10;src/main/java/thebitcrafter/autoreminder/&#10;  Main.java&#10;  domain/&#10;    model/&#10;      Event.java&#10;      EventType.java&#10;      Recurrence.java&#10;      EventConsumer.java&#10;    ports/&#10;      in/&#10;        EventCrudPort.java&#10;        ManageEventPort.java&#10;      out/&#10;        EventPublisher.java&#10;        repositories/&#10;          EventRepository.java&#10;    service/&#10;      ManageEventService.java&#10;  infrastructure/&#10;    memory/&#10;      InMemoryEventRepository.java&#10;    logging/&#10;      LoggingEventPublisher.java&#10;&#10;src/test/java/thebitcrafter/autoreminder/&#10;  ManageEventServiceTest.java&#10;&#10;pom.xml&#10;README.md&#10;```&#10;&#10;Key implementation notes&#10;- `Event` (domain model) contains scheduling logic: `nextTriggerAfter(ZonedDateTime)` returns the next scheduled ZonedDateTime according to the event's recurrence and zone.&#10;- `ManageEventService` implements both CRUD (`EventCrudPort`) and scheduling operations (`ManageEventPort`) and is the main orchestrator.&#10;- `InMemoryEventRepository` is a thread-safe, non-persistent ConcurrentHashMap-based repository used for quick local development and tests.&#10;- `LoggingEventPublisher` prints published events to stdout. A future `KafkaEventPublisher` will implement `EventPublisher` to produce scheduled events to Kafka.&#10;- Lombok is used for `Event` (builder, getters/setters, equals/hashCode, toString). Ensure Lombok is enabled in your IDE.&#10;&#10;Requirements&#10;- Java 21&#10;- Maven&#10;- Lombok (IDE support recommended)&#10;&#10;Build &amp; test&#10;&#10;Run tests:&#10;&#10;```bash&#10;mvn -q test&#10;```&#10;&#10;Run the demo `Main` class (from an IDE or via command line):&#10;&#10;```bash&#10;# build classes&#10;mvn -q -DskipTests=true compile&#10;# run using the classpath&#10;java -cp target/classes thebitcrafter.autoreminder.Main&#10;```&#10;&#10;(or run `Main` directly from your IDE)&#10;&#10;Notes about Kafka (next step)&#10;- A `KafkaEventPublisher` should implement `domain.ports.out.EventPublisher` and map scheduled events to a small JSON DTO containing: id, type, title, description, scheduledTime (ISO-8601), zone, recurrence, active.&#10;- Use `org.apache.kafka:kafka-clients` + Jackson (`jackson-databind` + `jackson-datatype-jsr310`) for serialization.&#10;- Topic: `events.scheduled` (or env-prefixed), key: `event.id`.&#10;- Producer config: `acks=all`, `enable.idempotence=true`, `retries&gt;0`, sensible `linger.ms`/`batch.size`.&#10;- For integration tests, use Testcontainers Kafka.&#10;&#10;Development tips&#10;- Event date handling: the implementation accounts for month length and leap years (e.g., Feb 29 handling).&#10;- One-off (`Recurrence.NONE`) events are deactivated after firing by `ManageEventService`.&#10;- The repo is currently in-memory; add a JPA adapter when you need persistence.&#10;&#10;Next steps (recommended)&#10;1. Implement `KafkaEventPublisher` adapter and add Kafka &amp; Jackson dependencies.&#10;2. Add a JPA-backed `EventRepository` implementation (or Spring Data adapter).&#10;3. Add a scheduled task (Quartz or Spring scheduler) that calls `triggerDueEvents()` periodically.&#10;4. Add metrics (Micrometer) and structured logging.&#10;&#10;Example — demo output&#10;```&#10;Next occurrence at: 2026-06-01T09:00:00+02:00[Europe/Paris]&#10;[PUBLISH] Event{id=..., type=BIRTHDAY, title='Alice Birthday', recurrence=YEARLY, active=true} at 2026-06-01T09:00:00+02:00[Europe/Paris]&#10;Triggered events: 1&#10;```&#10;&#10;License &amp; contribution&#10;- Add a `LICENSE` file suitable for your project (MIT recommended for small tools).&#10;- Fork, implement features on branches, add tests, open PRs.&#10;&#10;If you want, I can now:&#10;- Implement the `KafkaEventPublisher` adapter and wiring behind an environment flag, including required Maven deps and a basic integration test using Testcontainers. (Say &quot;implement Kafka publisher&quot; to proceed.)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>